Python封装结构与set原理和操作
IPython使用
官方主页:http://ipython.org/
封装和解构:
a=1,2,3
type(a)
a 如果不是写的列表则默认为一个值
c=(1) 它是一个单值 默认是int类型的
有逗号分割的时候默认为元祖类型的
x,y=y,x 先算等号右边再算左边的 拿元祖的封装过程是py特有的 左边是解构

封装:
将多个值使用逗号分割 组合在一起
本质上 返回一个元祖 只是省掉了小括号
python特有语法 被很多语言学习和借鉴
t1=(1,2) 定义为元祖
t2=1,2将1和2封装成元祖
type(1)
type(2)

x,y=1,2 这个可以
x,y,z=1,2 这个时候提示没有办法解开 因为tuple只有两个元素冲突了

x,y=list((2,3))
x,y 
只要元素个数一样就可以解构
[a,b]=[12,34]

非线性:元素随机的 
线性 元素规律排序的

头尾中间
*mid=能吃多少吃多少
head,*xxx,tail=(1,2)
head=1 头
tail=2 尾
*xxx=[] 尽可能多 有可能没有

head,*xxx=(1,2)
head=1
*xxx=[2]

*xxx=(2,1) 单独使用不可以加*


head,*mid,tail="adaddadaa"  列表可以解构


partition函数在解构的时候用_丢掉即可


解构不用索引可以直接从一个复杂的列表中提取出一个想要的值
解构 配合丢弃变量就可以发挥非常好的功能


补充:

举例:
a=4
b=5
temp=a
a=b
b=temp
等价于
a,b=b,a
上句中,等号右边使用了封装,而左边就是用了解构

解构
把线性解构的元素解开 并顺序的赋给其他变量
左边接纳的变量数要和右边解开的元素个数一致
举例:
lst=[3,5]
first,second = lst
print(first,second)

举例:
a,b=1,2
a,b=(1,2)
a,b=[1,2]
a,b=[10,20]
a,b={10,20}
a,b={'a':10,'b':20}
a,b={10,20,30}
a,*b={10,20,30}
[a,b]=(1,2)
[a,b]=10,20
(a,b)={30,40}



丢弃变量:
这是一个惯例,是一个不成文的约定,不是标准
如果不关心一个变量,就可以定义改变量的名字为_
_是一个合法的标识符,也可以作为一个有效的变量使用，但是定义成下划线就是希望不要被使用,除非你明确知道这个数据需要使用
举例
lst=[9,8,7,20]
first,*second=lst
head,*_,tail=lst
print(head)
print(tail)
#_是一个合法的标识符看到下划线就知道这个变量就是不想被使用
lst=[9,8,7,20]
first,*second=lst
print(_)
print(tail)
print(_)

丢弃变量
总结:_这个变量本身无任何语义,没有任何可读性,所以不是用来给人使用的
python中很多库 都是用这个变量,使用十分广泛,请不要在不明确变量作用域的情况下 使用_导致和库中_冲突
练习:
lst=list(range(10)) 这样一个列表取出第二个 第四个 倒数第二个
lst=list(range(10))
print(lst)
_,a,_,b,*_,c,_=lst
print(a,b,c)




练习:
从lst=[1,(2,3,4),5]中提取出4来
环境变量JAVA_HOME=/usr/bin,返回变量名和路径
对列表[9,8,1,5,6,3,2,0]使用冒泡排序,要求使用封装和结构来交互数据


1.
lst=[1,(2,3,4),5]
a,(b,c,d),e=lst
print(a,b,c,d,e)
_,(*_,val),*_=lst
print(val)
_,[*_,val],*_=lst
print(val)






练习:
环境变量JAVA_HOME=/usr/bin返回变量名和路径
key,_,val="JAVA_HOME=/usr/bin".parttion('=')
print(key)
print(val)

总结:
解构,是Python提供的很好的功能,可以方便的提取复杂数据结构的值
配合_使用会更加便利








